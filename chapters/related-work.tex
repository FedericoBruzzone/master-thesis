\chapter{Related Work}\label{chap:related-work:RelatedWork}

According to Tomasetti~\cite{tomassetti_complete_2017}, an external Domain-Specific Language in contrast to an internal one has tool support. So, in order to build this support language workbenches come to the rescue.
Nowadays, developers are increasingly using IDEs to write code, both for general-purpose languages (GPLs) and for domain-specific languages (DSLs), as they provide features such as syntax highlighting, code completion, and code navigation, thanks also to the Language Server Protocol (LSP) \cite{Rodriguez-Echeverria18a}.
To develop this kind of tool support, there are various language workbenches available that simplify the creation of abstract syntax, parsers, editors, and generators~\cite{Fowler05}.

In this chapter, we will present some of the most relevant language workbenches and tools that are available to support the language development process (Section~\ref{sec:related-work:syntax-semantics}). We will also present some of the most relevant tools that support modularization and composition of languages (Section~\ref{sec:related-work:modularization}). Finally, we will present some of the most relevant tools that support IDE and LSP generation (Section~\ref{sec:related-work:ide-support}).

\section{Syntax and Semantics Definition in Language Workbenches}\label{sec:related-work:syntax-semantics}

\subsection{JustAdd}\label{subsec:related-work:justadd}

\textit{JustAdd}~\cite{Ekman07b} is a modular compiler construction system developed at the Computer Science department of the Lund University.
It doesnâ€™t offer built-in support for concrete syntax definition or parser generation, however it can be integrated with third-party parser generators; language development in JastAdd, instead, is focused on modeling the AST as an object-oriented class hierarchy. Semantic phases are defined as methods in the AST classes, and the compiler is generated by the JastAdd compiler generator.

\subsection{Melange}\label{subsec:related-work:melange}
\textit{Melange}~\cite{Degueule15}  is a language workbench developed by the DiverSE research team at the Institut National de Recherche en Informatique et en Automatique (INRIA). Based on the Eclipse Modeling Framework (EMF)~\cite{Steinberg08}, Melange is meant to be used for the development of domain-specific languages. Abstract syntax support is provided by EMF, while concrete syntax is defined using the Xtext (Sect.~\ref{subsec:related-work:xtext}) language workbench.
Semantics is specified using the Kermeta 3 (K3) language~\cite{Jezequel15} which is based on Xtend\footnote{\url{https://www.eclipse.org/xtend/}}.

\subsection{MontiCore}\label{subsec:related-work:monticore}
\textit{MontiCore}~\cite{Krahn10} is a language workbench developed by the Software Engineering group at the RWTH Aachen University. Using a single DLS it is possible to define the abstract syntax, the concrete syntax; it takes one or more grammars as input and generates Java source code.
A visitor pattern is written in Java to define the semantics of the language.

\subsection{MPS -- Meta Programming System}\label{subsec:related-work:mps}
\textit{Meta Programming System}~\cite{Volter11, Voelter12} is a developement environment developed by JetBrains\footnote{\url{https://www.jetbrains.com}}. It is a \textit{projectional editor}~\cite{Voelter14} that allows the definition of abstract syntax and concrete syntax through a graphical editor. In order to add semantics, MPS provides a set of methods written in a Java-like language called \textit{BaseLanguage}.

\subsection{Rascal}\label{subsec:related-work:rascal}

\textit{Rescal}~\cite{Klint09b} is a meta-programming language developed at the Centrum Wiskunde \& Informatica (CWI) in Amsterdam. The abstract syntax is defined using algebraic data types (ADTs), while the concrete syntax is defined SDF~\cite{Heering89c} (also used in Spoofax, see Sect.~\ref{subsec:related-work:spoofax}). The semantics phase is defines as a function \texttt{eval} that takes an AST as input and with pattern matching evaluates the AST.

\subsection{Spoofax}\label{subsec:related-work:spoofax}

\textit{Spoofax}~\cite{Visser10} is a language workbench developed at the Delft University of Technology. It is an Eclipse based solution that provides support that use \textit{Syntax Definition Formalism 3} (SDF3)~\cite{Heering89c} for defining grammars.
In Spoofax, the semantics is defined using the \textit{Stratego}~\cite{Visser01} language, which is a term rewriting language.Spoofax, the sew

\subsection{Xtext}\label{subsec:related-work:xtext}

\textit{Xtext}~\cite{Bettini13b} is a language workbench developed by the Eclipse Foundation. The grammar is written in Xtext language, which is capable of generating both the ANTLR-based~\cite{Parr95} parser and EMF~\cite{Steinberg08} model used to represent the AST.  Semantics is in fact defined by implementing a code generator; this integrates \textit{out of the box} with Eclipse's built-in system.system. Xtext is distributed with \textit{Xtend}~\cite{Bettini13b}, a Java-like language that can be used to define the semantics of the language.

\section{Modularization and Composition in Language Workbenches}\label{sec:related-work:modularization}
Finding and working with the right abstractions for describing a problem or its solution is one of the central pillars of software engineering~\cite{Voelter12}.
In fact, modularization and composition are important and advanced features in language workbenches. They allow the developer to define a language by composing multiple features, each of which can be developed independently and then combined to create a new language.

Developers typically tackle the complexity of building an interpreter by using a vertical, functional decomposition approach. This method generally involves creating distinct phases for a lexer, parser, semantic analyzer, and code evaluator. While organizing the process into these phases is beneficial, it is not sufficient on its own~\cite{Cazzola16e}.
According to Bosch~\cite{Bosch96}, a vertical decomposition still results in complex compilers or interpreters that are hard to maintain, extend and whose pieces are hardly reusable. He suggests that a vertical, functional decomposition should be accompanied by a horizontal, structural decomposition.

A component can be any language feature (see Sect.~\ref{sec:background:software-and-language-product-lines}) that can be reused across different languages. Syntax and semantics are commonly used together to define a language feature, but other features can be defined as well. Each feature can be precompiled~\cite{Cazzola13e} or not. There are several language workbenches that support modularization and composition of languages, either with precompiled components or not. Different language workbenches provide different levels of support for modularization and composition of languages. In the following, we will present some of the most relevant language workbenches.

Following the order of the previous section, we will present the language workbenches that support modularization and composition of languages. \textbf{JustAdd} allows the developer to define a language by composing multiple features, but it requires that syntax and semantics have the same signature. On the other hand, thanks to an Encore model, that is a declarative specification of a set of classes, each of which can contain fields, methods, and constraints, \textbf{Melange} support composition. Encore models can be composed by renaming elements, which allows the developer to define a new language by composing multiple features. Another language workbench that supports modularization and composition of languages is \textbf{MontiCore}. It supports multiple grammars inheritance, but it does not give support for adding new attributes to imported symbols. Due to the fact that \textbf{MPS} is a projectional editor, without parsing phase, it allows arbitrary notations to be combined. It supports composition of languages, but it does not support precompiled components. Moving to \textbf{Rascal}, rewrite rules is the principal mechanism to compose features; the obstacle is that certain identifiers, such as constructors for the operations ADT, must be consistent across seemingly unrelated modules. \textbf{Spoofax} is unique in its support for modularization and composition of languages. It uses \textit{Stratego}~\cite{Bravenboer08} to rewrite the tree, allowing the conversion from an AST to another. \textbf{Xtext}, instead, supporting only single grammar inheritance, does not support composition of languages.

The only language workbenches that support precompiled components are \textbf{Neverlang}~\cite{Cazzola13e}. While in \textbf{MontiCore} and \textbf{Xtext} code implementing semantics can be excluded from package, but the grammar cannot be excluded, so it is possible have a partial support for precompiled components.

\begin{table}[t]
    \rowcolors{2}{gray!25}{white}
    % \setlength\arrayrulewidth{0pt}
    \centering
    \begin{tabular}{ c c c }
        \toprule \textbf{Language Workbench} & \textbf{Modularization Supp.} & \textbf{Precompiled Features Supp.} \\
        \midrule
        JustAdd & \circleleft & \circlewhite \\
        Melange & \circleblack & \circlewhite \\
        MontiCore & \circleleft & \circleleft \\
        MPS & \circleblack & \circlewhite \\
        Rascal & \circlewhite & \circlewhite \\
        Spoofax & \circleblack & \circleleft \\
        Xtext & \circlewhite & \circleleft \\
        Neverlang & \circleblack & \circleblack \\
        \bottomrule
    \end{tabular}
    \caption{Language Workbenches Supporting Modularization, Composition and Precompiled Features}
    \label{tab:related-work:modularization-composition}
\end{table}

In Table~\ref{tab:related-work:modularization-composition} we summarize the support for modularization and composition of the language workbenches presented in this section. In the first column, we list the language workbenches. Using \circleblack, \circleleft, and \circlewhite, in the second and third columns, we indicate whether the language workbench supports, partially supports, or does not support modularization and composition, respectively.

\section{IDE and LSP Support}\label{sec:related-work:ide-support}

Xtext is by now the only language workbench supporting the LSP.~\cite{Bunder19a}


\begin{table}[t]
    \rowcolors{2}{gray!25}{white}
    % \setlength\arrayrulewidth{0pt}
    \centering
    \begin{tabular}{ c c c c }
        \toprule \textbf{Language Workbench} & \textbf{Native IDE gen.} & \textbf{Native LSP Gen.} & \textbf{LSP Mod.} \\
        \midrule
        JustAdd & \circlewhite & \circlewhite \\
        Melange & \circleblack & \circlewhite \\
        MontiCore & 3 & \circlewhite \\
        MPS & \circleblack & \circlewhite \\
        Rascal & \circleblack & \circlewhite \\
        Spoofax & \circleblack & \circlewhite \\
        Xtext & \circleblack & \circleblack \\
        \bottomrule
    \end{tabular}
    \caption{Language Workbenches Supporting Modularization and Composition}
    \label{tab:related-work:modularization-composition}
\end{table}
