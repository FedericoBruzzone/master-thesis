\chapter{Related Work}\label{chap:RelatedWork}

According to Tomasetti~\cite{tomassetti_complete_2017}, an external Domain-Specific Language in contrast to an internal one has tool support. So, in order to build this support language workbenches come to the rescue.
Nowadays, developers are increasingly using IDEs to write code, as they provide features such as syntax highlighting, code completion, and code navigation, thanks also to the Language Server Protocol (LSP) \cite{Rodriguez-Echeverria18a}.
To develop this kind of tool support, there are various language workbenches available that simplify the creation of abstract syntax, parsers, editors, and generators~\cite{Fowler05}.

In this chapter, we will present some of the most relevant language workbenches and tools that are available to support the language development process, and we will also discuss the importance of modularization and composition in the context of language workbenches and IDEs generation.

\section{Syntax and Semantics Definition in Language Workbenches}\label{sec:background:syntax-semantics}

\subsection{JustAdd}\label{subsec:background:justadd}

\textit{JustAdd}~\cite{Ekman07b} is a modular compiler construction system developed at the Computer Science department of the Lund University.
It doesnâ€™t offer built-in support for concrete syntax definition or parser generation, however it can be integrated with third-party parser generators; language development in JastAdd, instead, is focused on modeling the AST as an object-oriented class hierarchy. Semantic phases are defined as methods in the AST classes, and the compiler is generated by the JastAdd compiler generator.

\subsection{Melange}\label{subsec:background:melange}
\textit{Melange}~\cite{Degueule15}  is a language workbench developed by the DiverSE research team at the Institut National de Recherche en Informatique et en Automatique (INRIA). Based on the Eclipse Modeling Framework (EMF)~\cite{Steinberg08}, Melange is meant to be used for the development of domain-specific languages. Abstract syntax support is provided by EMF, while concrete syntax is defined using the Xtext (Sect.~\ref{subsec:background:xtext}) language workbench.
Semantic is specified using the Kermeta 3 (K3) language~\cite{Jezequel15} which is based on Xtend\footnote{\url{https://www.eclipse.org/xtend/}}.

\subsection{MontiCore}\label{subsec:background:monticore}
\textit{MontiCore}~\cite{Krahn10} is a language workbench developed by the Software Engineering group at the RWTH Aachen University. Using a single DLS it is possible to define the abstract syntax, the concrete syntax; it takes one or more grammars as input and generates Java source code.
A visitor pattern is written in Java to define the semantics of the language.

\subsection{MPS -- Meta Programming System}\label{subsec:background:mps}
\textit{Meta Programming System}~\cite{Volter11, Voelter12} is a developement environment developed by JetBrains\footnote{\url{https://www.jetbrains.com}}. It is a \textit{projectional editor}~\cite{Voelter14} that allows the definition of abstract syntax and concrete syntax through a graphical editor. In order to add semantics, MPS provides a set of methods written in a Java-like language called \textit{BaseLanguage}.

\subsection{Rascal}\label{subsec:background:rascal}

\textit{Rescal}~\cite{Klint09b} is a meta-programming language developed at the Centrum Wiskunde \& Informatica (CWI) in Amsterdam. The abstract syntax is defined using algebraic data types (ADTs), while the concrete syntax is defined SDF~\cite{Heering89c} (also used in Spoofax, see Sect.~\ref{subsec:background:spoofax}). The semantics phase is defines as a function \texttt{eval} that takes an AST as input and with pattern matching evaluates the AST.

\subsection{Spoofax}\label{subsec:background:spoofax}

\subsection{Xtext}\label{subsec:background:xtext}


\section{Modularization and Composition}\label{sec:background:modularization}


\section{IDE Support}\label{sec:background:ide-support}

\section{LSP Support}\label{sec:background:lsp-support}
Xtext is by now the only language workbench supporting the LSP.~\cite{Bunder19a}






