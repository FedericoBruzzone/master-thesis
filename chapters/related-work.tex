\chapter{Related Work}\label{chap:related-work:RelatedWork}

According to Tomasetti~\cite{tomassetti_complete_2017}, an external Domain-Specific Language in contrast to an internal one has tool support. So, in order to build this support language workbenches come to the rescue.
Nowadays, developers are increasingly using IDEs to write code, both for general-purpose languages (GPLs) and for domain-specific languages (DSLs), as they provide features such as syntax highlighting, code completion, and code navigation, thanks also to the Language Server Protocol (LSP) \cite{Rodriguez-Echeverria18a}.
To develop this kind of tool support, there are various language workbenches available that simplify the creation of abstract syntax, parsers, editors, and generators~\cite{Fowler05}.

In this chapter, we will present some of the most relevant language workbenches and tools that are available to support the language development process (Section~\ref{sec:related-work:syntax-semantics}). We will also present some of the most relevant tools that support modularization and composition of languages (Section~\ref{sec:related-work:modularization}). Finally, we will present some of the most relevant tools that support IDE and LSP generation (Section~\ref{sec:related-work:ide-support}).

\section{Syntax and Semantics Definition in Language Workbenches}\label{sec:related-work:syntax-semantics}

\subsection{JustAdd}\label{subsec:related-work:justadd}

\textit{JustAdd}~\cite{Ekman07b} is a modular compiler construction system developed at the Computer Science department of the Lund University.
It doesnâ€™t offer built-in support for concrete syntax definition or parser generation, however it can be integrated with third-party parser generators; language development in JastAdd, instead, is focused on modeling the AST as an object-oriented class hierarchy. Semantic phases are defined as methods in the AST classes, and the compiler is generated by the JastAdd compiler generator.

\subsection{Melange}\label{subsec:related-work:melange}
\textit{Melange}~\cite{Degueule15}  is a language workbench developed by the DiverSE research team at the Institut National de Recherche en Informatique et en Automatique (INRIA). Based on the Eclipse Modeling Framework (EMF)~\cite{Steinberg08}, Melange is meant to be used for the development of domain-specific languages. Abstract syntax support is provided by EMF, while concrete syntax is defined using the Xtext (Sect.~\ref{subsec:related-work:xtext}) language workbench.
Semantics is specified using the Kermeta 3 (K3) language~\cite{Jezequel15} which is based on Xtend\footnote{\url{https://www.eclipse.org/xtend/}}.

\subsection{MontiCore}\label{subsec:related-work:monticore}
\textit{MontiCore}~\cite{Krahn10} is a language workbench developed by the Software Engineering group at the RWTH Aachen University. Using a single DLS it is possible to define the abstract syntax, the concrete syntax; it takes one or more grammars as input and generates Java source code.
A visitor pattern is written in Java to define the semantics of the language.

\subsection{MPS -- Meta Programming System}\label{subsec:related-work:mps}
\textit{Meta Programming System}~\cite{Volter11, Voelter12} is a developement environment developed by JetBrains\footnote{\url{https://www.jetbrains.com}}. It is a \textit{projectional editor}~\cite{Voelter14} that allows the definition of abstract syntax and concrete syntax through a graphical editor. In order to add semantics, MPS provides a set of methods written in a Java-like language called \textit{BaseLanguage}.

\subsection{Rascal}\label{subsec:related-work:rascal}

\textit{Rescal}~\cite{Klint09b} is a meta-programming language developed at the Centrum Wiskunde \& Informatica (CWI) in Amsterdam. The abstract syntax is defined using algebraic data types (ADTs), while the concrete syntax is defined SDF~\cite{Heering89c} (also used in Spoofax, see Sect.~\ref{subsec:related-work:spoofax}). The semantics phase is defines as a function \texttt{eval} that takes an AST as input and with pattern matching evaluates the AST.

\subsection{Spoofax}\label{subsec:related-work:spoofax}

\textit{Spoofax}~\cite{Visser10} is a language workbench developed at the Delft University of Technology. It is an Eclipse based solution that provides support that use \textit{Syntax Definition Formalism 3} (SDF3)~\cite{Heering89c} for defining grammars.
In Spoofax, the semantics is defined using the \textit{Stratego}~\cite{Visser01} language, which is a term rewriting language.Spoofax, the sew

\subsection{Xtext}\label{subsec:related-work:xtext}

\textit{Xtext}~\cite{Bettini13b} is a language workbench developed by the Eclipse Foundation. The grammar is written in Xtext language, which is capable of generating both the ANTLR-based~\cite{Parr95} parser and EMF~\cite{Steinberg08} model used to represent the AST.  Semantics is in fact defined by implementing a code generator; this integrates \textit{out of the box} with Eclipse's built-in system.system. Xtext is distributed with \textit{Xtend}~\cite{Bettini13b}, a Java-like language that can be used to define the semantics of the language.

\section{Modularization and Composition in Language Workbenches}\label{sec:related-work:modularization}

Finding and working with the right abstractions for describing a problem or its solution is one of the central pillars of software engineering~\cite{Voelter12}. Modularization and composition are critical and advanced features in language workbenches, enabling developers to define a language by combining multiple features. Each feature can be developed independently and then integrated to create a new language, enhancing flexibility and reuse.

Developers typically manage the complexity of building an interpreter by using a vertical, functional decomposition approach. This method generally involves creating distinct phases for a lexer, parser, semantic analyzer, and code evaluator. While organizing the process into these phases is beneficial, it is not sufficient on its own~\cite{Cazzola16e}. According to Bosch~\cite{Bosch96}, a vertical decomposition still results in complex compilers or interpreters that are hard to maintain and extend, with components that are seldom reusable. He suggests that a vertical, functional decomposition should be accompanied by a horizontal, structural decomposition to better manage complexity.

A component can be any language feature (see Sect.\ref{sec:background:software-and-language-product-lines}) that can be reused across different languages. Syntax and semantics are commonly used together to define a language feature, but other features can be defined as well. Each feature can be precompiled\cite{Cazzola13e} or not. Several language workbenches support modularization and composition of languages, either with precompiled components or without. Different language workbenches provide varying levels of support for these features. In the following, we will present some of the most relevant language workbenches.

Following the order of the previous section, we will present the language workbenches that support modularization and composition of languages. \textbf{JustAdd} allows the developer to define a language by composing multiple features, but it requires that syntax and semantics have the same signature. Conversely, \textbf{Melange} supports composition through Encore models, which are declarative specifications of a set of classes that can contain fields, methods, and constraints. Encore models can be composed by renaming elements, allowing the developer to define a new language by combining multiple features. Another language workbench that supports modularization and composition of languages is \textbf{MontiCore}. It supports multiple grammar inheritance, but it does not support adding new attributes to imported symbols. \textbf{MPS}, being a projectional editor without a parsing phase, allows arbitrary notations to be combined. It supports language composition but does not support precompiled components. Moving to \textbf{Rascal}, rewrite rules are the principal mechanism for composing features, but certain identifiers, such as constructors for the operations ADT, must be consistent across seemingly unrelated modules. \textbf{Spoofax} is unique in its support for modularization and composition of languages. It uses \textit{Stratego}~\cite{Bravenboer08} to rewrite the tree, allowing the conversion from one AST to another. In contrast, \textbf{Xtext}, supporting only single grammar inheritance, does not support language composition.

The only language workbench that supports precompiled components is \textbf{Neverlang}~\cite{Cazzola13e}. While in \textbf{MontiCore} and \textbf{Xtext}, code implementing semantics can be excluded from the package, the grammar cannot be excluded, allowing for partial support for precompiled components.

Additionally, some language workbenches offer unique approaches to modularization and composition. For instance, \textbf{Spoofax} employs a meta-programming language, Stratego, which specializes in program transformation. This approach enables the composition of language features by transforming abstract syntax trees (ASTs), providing a flexible mechanism for integrating various language aspects. On the other hand, \textbf{MPS} leverages its projectional editing paradigm to support modularization, allowing developers to mix and match different syntactic constructs seamlessly.

\begin{table}[t]
    \rowcolors{2}{gray!25}{white}
    % \setlength\arrayrulewidth{0pt}
    \centering
    \begin{tabular}{ c c c }
        \toprule \textbf{Language Workbench} & \textbf{Modularization Supp.} & \textbf{Precompiled Features Supp.} \\
        \midrule
        JustAdd & \circleleft & \circlewhite \\
        Melange & \circleblack & \circlewhite \\
        MontiCore & \circleleft & \circleleft \\
        MPS & \circleblack & \circlewhite \\
        Rascal & \circlewhite & \circlewhite \\
        Spoofax & \circleblack & \circleleft \\
        Xtext & \circlewhite & \circleleft \\
        Neverlang & \circleblack & \circleblack \\
        \bottomrule
    \end{tabular}
    \caption{Language Workbenches Supporting Modularization, Composition and Precompiled Features}
    \label{tab:related-work:modularization-composition}
\end{table}

In Table~\ref{tab:related-work:modularization-composition}, we summarize the support for modularization and composition of the language workbenches presented in this section. In the first column, we list the language workbenches. Using \circleblack, \circleleft, and \circlewhite in the second and third columns, we indicate whether the language workbench supports, partially supports, or does not support modularization and composition, respectively. This overview highlights the varying capabilities of each tool, providing a clear comparison for developers looking to select a language workbench that best suits their needs.

\section{IDE and LSP Generation and Usage}\label{sec:related-work:ide-support}

IDE generation is a crucial feature for language workbenches, as it enables developers to create tools that support the development of domain-specific languages (DSLs) within integrated development environments (IDEs).
Nowadays, Language Server Protocol (LSP) is a key technology that enables the development of language servers that can be used in any IDE that supports the protocol. In this section, we will present some of the most relevant language workbenches that support IDE and LSP generation.

Four of the tools are closely integrated with IDE ecosystems. \textbf{Spoofax}, \textbf{Xtext}, and \textbf{Melange} are all Eclipse-based frameworks. Spoofax and Xtext support the automatic generation of plugins for text editor syntax highlighting and real-time visualization of the parsed AST (Eclipseâ€™s outline). Melange integrates with the EMF GUI-based model editor. In \textbf{MPS}, DSLs are both developed and used within the same IDE, with each concept (AST node type) having a default projectional editor component that can be optionally customized. \textbf{MontiCore} and \textbf{Rascal} can be used either as standalone command line programs or as Eclipse plugins. As detailed in~\cite{Krahn10}, Section 4.5 and~\cite{Inostroza21}, respectively, both MontiCore and Rascal support the generation of Eclipse tooling for the languages developed using them.

On the other hand, LSP generation is a feature that is not supported by all language workbenches. JustAdd, Melange, MontiCore, MPS, Rascal, and Spoofax all do not support LSP generation. \textbf{Xtext}, according to~\cite{Bunder19a}, is the only language workbench that supports the LSP.

Finally, also LSP modularization is a feature that is not supported by all language workbenches. JustAdd, Melange, MontiCore, MPS, Rascal. \textbf{Xtext}, as explained in section \ref{sec:related-work:modularization}, does not support modularization and composition of languages, and therefore does not support LSP modularization.

\begin{table}[t]
    \rowcolors{2}{gray!25}{white}
    % \setlength\arrayrulewidth{0pt}
    \centering
    \begin{tabular}{ c c c c }
        \toprule \textbf{Language Workbench} & \textbf{Native IDE gen.} & \textbf{LSP Gen.} & \textbf{LSP Mod.} \\
        \midrule
        JustAdd & \circlewhite & \circlewhite & \circlewhite \\
        Melange & 3rd party (EMF) & \circlewhite & \circlewhite \\
        MontiCore & \circleblack & \circlewhite & \circlewhite \\
        MPS & \circleblack & \circlewhite & \circlewhite \\
        Rascal & \circleblack & \circlewhite & \circlewhite \\
        Spoofax & \circleblack & \circlewhite & \circlewhite \\
        Xtext & \circleblack & \circleblack & \circlewhite \\
        Neverlang & \circleblack & \circleblack & \circleblack \\
        \bottomrule
    \end{tabular}
    \caption{Language Workbenches Supporting Modularization and Composition}
    \label{tab:related-work:modularization-composition}
\end{table}

In Table~\ref{tab:related-work:ide-lsp-generation}, we summarize the support for IDE and LSP generation of the language workbenches presented in this section. In the first column, we list the language workbenches. Using \circleblack, \circlewhite, and \circleleft in the second, third, and fourth columns, we indicate whether the language workbench supports, partially supports, or does not support IDE generation, LSP generation, and LSP modularizatio, respectively.

