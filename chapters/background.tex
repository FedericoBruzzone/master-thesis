\chapter{Background}\label{chap:Background}

\begin{Listing}[t]
\centering
\begin{tikzpicture}
\draw[blue, very thick, rounded corners, fill=blue!20, anchor=north]
        (0,0) rectangle (4,3)
        node[anchor=north, align=center] at (2,3.5) {Editor};
\draw[gray, very thick, fill=gray!20]
        (0.15, 1.75) rectangle (3.85,2.75)
        node[black, text width=4cm, pos=.5, align=center] {Language-agnostic \linebreak editing support};
\draw[gray, very thick, fill=gray!20]
        (0.15, 0.25) rectangle (3.85,1.65)
        node[black, text width=4cm, pos=.5, align=center] {Editing actions \linebreak $\Updownarrow$ \linebreak  Text changes};

\draw[red, very thick, rounded corners, fill=red!20, anchor=north]
        (7,0) rectangle (11,3)
        node[anchor=north, align=center] at (9,3.5) {Server};
\draw[gray, very thick, fill=gray!20]
        (7.15, 1.75) rectangle (10.85,2.75)
        node[black, text width=4cm, pos=.5, align=center] {Language-specific \linebreak editing support};
\draw[gray, very thick, fill=gray!20]
        (7.15, 0.25) rectangle (10.85,1.65)
        node[black, text width=4cm, pos=.5, align=center] {Language actions \linebreak $\Updownarrow$ \linebreak Text Changes};

\draw[<->, very thick, >=stealth] (4,1.5) -- (7,1.5)
        node[midway,fill=white] {\emph{LSP}};
\end{tikzpicture}
\caption{LSP approach to language support. Borrowed from \cite{Rodriguez-Echeverria18a}}
\label{lst:lsp}
\end{Listing}

In this chapter, we provide an overview of the concepts and technologies that are relevant to the work presented in this thesis. We start by introducing the concept of language servers and the Language Server Protocol (LSP) in Section~\ref{sec:LanguageServerProtocol}. We then discuss language workbenches in Section~\ref{sec:LanguageWorkbenches}, type systems in Section~\ref{sec:TypeSystems}, and software and language product lines in Section~\ref{sec:SoftwareProductLines}.

The goal of this chapter is to provide the reader with the necessary background knowledge to understand the work presented in the following chapters. We assume that the reader has a basic understanding of programming languages and software development.

\section{Language Server Protocol}\label{sec:LanguageServerProtocol}
The Language Server Protocol\footnote{\url{https://microsoft.github.io/language-server-protocol}} (LSP) is a protocol that allows for the communication between a language server and an editor or an IDE. The LSP is used to decuple the a language-agnotic editor or integrated development environment (IDE) from the language-specific features of a language server (see Listing~\ref{lst:lsp}). This allows for the development of language servers that can be used with multiple editors or IDEs. The LSP is based on the stateless JSON-RPC protocol and defines a set of messages that are used to communicate between the language server and the editor or IDE.

Usually, the LSP Clients are developed as plugins for popular editors or IDEs decresing the effort to support a new language in a given editor. The LSP Clients are responsible for sending requests to the language server and processing the responses. The language server is responsible for providing language-specific features. The LSP defines a set of messages that are used to communicate between the language server and the editor or IDE. These messages include requests for code completion, code navigation, and code analysis, as well as notifications for changes to the document, diagnostics, and progress reports.

Language servers are \textit{de facto} standard for providing language-specific features in editors and IDEs. The LSP is supported by a wide range of editors and IDEs, including Noevim\footnote{\url{https://neovim.io/doc/user/lsp.html}}, Visual Studio Code\footnote{\url{https://code.visualstudio.com/api/language-extensions/language-server-extension-guide}}, Eclipse\footnote{\url{https://www.eclipse.org/community/eclipse_newsletter/2017/may/article1.php}}, and IntelliJ IDEA\footnote{\url{https://plugins.jetbrains.com/docs/intellij/language-server-protocol.html}}. There are several language servers available for popular programming languages, including Rust, TypeScript, Python, and Java and most of them are open-source\footnote{\url{https://microsoft.github.io/language-server-protocol/implementors/servers}}.

The LSP is initiated by Microsoft and is now an open standard that is maintained by the Language Server Protocol Working Group. It was designed for the use with the Visual Studio Code editor, but it has since been adopted by other editors and IDEs. The LSP is under open-source license and is available on GitHub\footnote{\url{https://github.com/microsoft/language-server-protocol}}.

\subsection{JSON-RPC}\label{subsec:JSONRPC}
The LSP uses JSON-RPC to communicate between a language server and an editor. JSON-RPC (v2)\footnote{\url{https://www.jsonrpc.org/specification}} is a stateless, light-weight remote procedure call (RPC) \cite{Birrell84} protocol that uses JSON as the data format.

RPC is a protocol that allows a client to call a procedure on a remote server. The client sends a request to the server, and the server sends a response back to the client. The JSON-RPC protocol defines a set of messages that are used to communicate between the client and the server. These messages include requests, responses, and notifications. The JSON-RPC protocol is designed to be simple and easy to implement, making it well-suited for use in web applications and other distributed systems.

JSON-RPC is a JSON based implementation of the RPC protocol. It defines a set of rules for encoding and decoding JSON data, as well as a set of rules for \textit{Request}, \textit{Notification}, and \textit{Response} messages. The messages are sent over a transport layer, such as HTTP or WebSockets. The JSON-RPC protocol is designed to be simple and easy to implement, making it well-suited for use in web applications and other distributed systems.

All messages refer to a \textit{method} that is a string containing the name of the method to be called. The \textit{params} field is an array or object containing the parameters to be passed to the method. Typically, messages are synchronous, meaning that the client waits for a response from the server before continuing. The \textit{id} field is a unique identifier for the message, which is used to match requests with responses. However, the JSON-RPC protocol also supports asynchronous messages, known as notifications, which do not require a response from the server. This is implemented by setting the \textit{id} field to \textit{null}, in which case the server does not send a response back to the client.

The JSON-RPC specification includes the ability for clients to batch multiple requests or notifications by sending them as a list. The server is expected to respond with a corresponding list of results for each request. Additionally, the server has the flexibility to process these requests concurrently.

\subsection{Command Specifications}\label{sec:CommandSpecification}
The LSP is defined on top of the JSON-RPC protocol described in section \ref{subsec:JSONRPC}. In abstract terms, the LSP defines a set of command that can be sent between a client and a server. In the Language Server Protocol Specification\footnote{https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification}, these commands are divided into four categories: \textit{Language Features}, \textit{Text Document Synchronization}, \textit{Workspace Features}, and \textit{Window Features}.

\subsubsection{Language Features}\label{subsec:LanguageFeatures}
The \textit{Language Features} provide the smarts of the language server. Usually, the client sends a request to the server to get information about the document as a tuple of \texttt{TextDocument} and \texttt{Position}. \textit{Code comprehension} and \textit{Coding Features} are the two main categories of commands in this category.

Here a brief description of the most important commands in this category:
\begin{itemize}
    \item \texttt{textDocument/completion}: The completion request is sent from the client to the server to compute completion items at a given cursor position. Completion items are presented in the editor's user interface. If computing full completion items is expensive, servers can additionally provide a handler for the completion item resolve request (\texttt{completionItem/resolve}). This request is sent when a completion item is selected in the user interface.
    \item \texttt{textDocument/hover}: The hover request is sent from the client to the server to request hover information at a given text document position. Hover information typically includes the symbol's signature and documentation.
    \item \texttt{textDocument/definition}: The definition request is sent from the client to the server to resolve the definition location of a symbol at a given text document position.
    \item \texttt{textDocument/references}: The references request is sent from the client to the server to resolve project-wide references for the symbol denoted by the given text document position.
    \item \texttt{textDocument/documentHighlight}: The document highlight request is sent from the client to the server to resolve a document highlights for a given text document position. For programming languages, this usually highlights all references to the symbol denoted by the given text document position.
\end{itemize}

\subsubsection{Text Document Synchronization}\label{subsec:TextDocumentSynchronization}
The \textit{Text Document Synchronization} commands are used to notify the server of changes to the document. Client support for \texttt{textDocument/didOpen}, \texttt{textDocument/didChange}, \texttt{textDocument/didClose} is mandatory. This includes the ability to fully and incrementally synchronize changes to the document, such as inserting, deleting, and replacing text.

Here a brief description of the most important commands in this category:
\begin{itemize}
    \item \texttt{textDocument/didOpen}: The document open notification signals that the client is now managing a text document. The server should not read the document using its URI. Open notifications are balanced with close notifications, with only one open notification allowed at a time for a document. The server's ability to fulfill requests is unaffected by a document's open or closed status.
    \item \texttt{textDocument/didChange}: The document change notification is sent from the client to the server to signal changes to a text document. In response, the server should compute a new version of the document's content. The server should not rely on the client to send a specific sequence of change events. The server is free to compute the new version of the document on the fly.
    \item \texttt{textDocument/didClose}: The document close notification is sent from the client to the server when the document is no longer managed by the client. The document's URI is no longer valid and the server should not resolve the document using the URI.
    \item \texttt{textDocument/didSave}: The document save notification is sent from the client to the server when the document is saved. The notification is sent after the document has been saved.
\end{itemize}

\subsubsection{Workspace Features}\label{subsec:WorkspaceFeatures}
The \texttt{Workspace Features} category includes commands that allow the client to interact with the workspace. The workspace is the collection of open documents and the client's configuration. The workspace commands are used to manage the workspace, such as symbol search, workspace configuration and client configuration.

Here a brief description of the most important commands in this category:
\begin{itemize}
    \item \texttt{workspace/symbol}: The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string. The request can be used to populate a list of symbols matching the query string in the user interface.
    \item \texttt{workspace/configuration}: The workspace configuration request is sent from the client to the server to fetch configuration settings from the server. The request can fetch configuration settings from the client's workspace or from the server's configuration.
    \item \texttt{workspace/didChangeConfiguration}: The configuration change notification is sent from the client to the server to signal changes to the client's configuration settings. The server should use the new configuration settings to update its behavior.
    \item \texttt{workspace/didChangeWorkspaceFolders}: The workspace folder change notification is sent from the client to the server to signal changes to the workspace's folders. The server should use the new workspace folders to update its behavior.
\end{itemize}

\subsubsection{Window Features}\label{subsec:WindowFeatures}

The \texttt{Window Features} category includes commands that allow the client to interact with the window. The window is the client's user interface, such as the editor, the sidebar, and the status bar. The window commands are used to manage the window, such as showing messages, showing notifications, and showing progress.

Here a brief description of the most important commands in this category:
\begin{itemize}
    \item \texttt{window/showMessage}: The show message notification is sent from the server to the client to show a message to the user. The message can be shown in a variety of ways, such as a dialog box, a status bar, or a notification.
    \item \texttt{window/showMessageRequest}: The show message request is sent from the server to the client to show a message to the user and get a response. The message can be shown in a variety of ways, such as a dialog box, a status bar, or a notification.
    \item \texttt{window/logMessage}: The log message notification is sent from the server to the client to log a message. The message can be logged in a variety of ways, such as a console, a file, or a database.
    \item \texttt{window/showMessageRequest}: The show message request is sent from the server to the client to show a message to the user and get a response. The message can be shown in a variety of ways, such as a dialog box, a status bar, or a notification.
\end{itemize}

\subsection{Key Methods Overview}\label{subsec:KeyMethodsOverview}

Six \textit{key methods} have been identified by langserver organization\footnote{\url{https://langserver.org}} as the most important methods to be implemented by a language server. These capabilities are:
\begin{enumerate}
    \item \textbf{Diagnostic Analyze} source code --- Parse and Type-check the source code to provide diagnostics.
    \item \textbf{Workspace/Document Symbols} --- List all symbols in the workspace.
    \item \textbf{Jump to Definition} --- Find and jump to the definition of a symbol.
    \item \textbf{Find References} --- List all usages of a symbol.
    \item \textbf{Hover Information} --- Show information about a symbol at the cursor.
    \item \textbf{Code Completion} --- Provide completions for a symbol at the cursor.
\end{enumerate}

\subsubsection{Diagnostic Analysis}\label{subsubsec:DiagnosticAnalysis}

The diagnostic analysis is the process of parsing and type-checking the source code to provide diagnostics. The diagnostics are used to identify errors and warnings in the source code, such as syntax errors, type errors, and unused variables. The diagnostics are presented to the user in the editor's user interface, such as a list of errors and warnings in the sidebar.

File update and diagnostic analysis are passive. Thay are sent as notifications in order to avoid blocking communication between the client and the server.

In the figure \ref{fig:diagnostic} we can see an example of diagnostics in Neovim generated by the Rust Language Server. It shows a list of errors and suggestions coused by the concatenation of two \texttt{\&str} variables.

\begin{figure}[t]
    \centering
    \fcolorbox{black}{white}{
        \includegraphics[width=0.9\linewidth]{imgs/background_diagnostic.png}
    }
    \caption{Showing diagnostics in Neovim generated by the Rust Language Server.}
    \label{fig:diagnostic}
\end{figure}

\subsubsection{Workspace/Document Symbols}\label{subsubsec:WorkspaceDocumentSymbols}

\fbox{
    \parbox{\textwidth}{
        \centering
        \textbf{RPC Method}:  \href{https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/\#workspace_symbol}{textDocument/workspaceSymbol} or \href{https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/\#textDocument_documentSymbol}{textDocument/documentSymbol}
    }
}
\hfill \break

\noindent
This feature is defined as both a \textit{Language Feature} and \textit{Workspace Feature}.

The \texttt{textDocument/workspaceSymbol} request is sent from the client to the server to list project-wide symbols matching the query string. The request can be used to populate a list of symbols matching the query string in the user interface. The granularity of the listed symbols depends on the language server implementation.

The difference between \texttt{textDocument/workspaceSymbol} and \texttt{textDocument/documentSymbol} is that the first one takes into account the visibility of the symbols in the workspace showing only the public ones. The second one shows all symbols in the document.


\subsubsection{Jump to Definition}\label{subsubsec:JumpToDefinition}
\fbox{
    \parbox{\textwidth}{
        \centering
        \textbf{RPC Method}:  \href{https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/\#textDocument_definition}{textDocument/definition}
    }
}
\hfill \break

The code navigation is an important feature of the LSP.

The \texttt{textDocument/definition} request is sent from the client to the server to resolve the definition location of a symbol at a given text document position. The server should return the location of the symbol's definition, such as the file path and line number.

In the figure \ref{fig:hover} we can see that at the top of floating window there is the signature of the function \texttt{hello\_world} meaning that the goind to definition will take us to the function definition.

\subsubsection{Find References}
\fbox{
    \parbox{\textwidth}{
        \centering
        \textbf{RPC Method}:  \href{https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/\#textDocument_references}{textDocument/references}
    }
}
\hfill \break

The retrieval of references is the inverse of the jump to definition explained in the previous section (\ref{subsubsec:JumpToDefinition}).

The \texttt{textDocument/references} request is sent from the client to the server to resolve project-wide references for the symbol denoted by the given text document position. The server should return a list of references to the symbol, such as the file path, line number, and the column number.

In the figure \ref{fig:references} we can see that the function \texttt{hello\_world} is being referenced twice in the \texttt{main} function and another occurence is the function definition. In fact, three references are shown in the right window.

\begin{figure}[t]
    \centering
    \fcolorbox{black}{white}{
        \includegraphics[width=0.9\linewidth]{imgs/background_references.png}
    }
    \caption{Finding references in Neovim generated by the Rust Language Server.}
    \label{fig:references}
\end{figure}

\subsubsection{Hover Information}

\fbox{
    \parbox{\textwidth}{
        \centering
        \textbf{RPC Method}:  \href{https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/\#textDocument_hover}{textDocument/hover}
    }
}
\hfill \break

The hover information is a feature that shows information about a symbol at the cursor. The information typically includes the symbol's signature and documentation. This is triggered by the user hovering the mouse over a symbol in the editor or by pressing a keybinding.

A request is sent from the client to the server to request hover information at a given text document position. The server should return hover information for the symbol at the given position, such as the symbol's signature and documentation.

In the figure \ref{fig:hover} we can see that the function \texttt{hello\_world} is being hovered and the signature of the function is shown in the floating window. The signature is \texttt{fn hello\_world() -> String} and the documentation, written in the comment above the function, is also shown.

\begin{figure}[t]
    \centering
    \fcolorbox{black}{white}{
        \includegraphics[width=0.9\linewidth]{imgs/background_hover.png}
    }
    \caption{Hover information in Neovim generated by the Rust Language Server.}
    \label{fig:hover}
\end{figure}

\subsubsection{Code Completion}
\fbox{
    \parbox{\textwidth}{
        \centering
        \textbf{RPC Method}:  \href{https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/\#textDocument_completion}{textDocument/completion}
    }
}
\hfill \break

The code completion is a feature that provides completions for a symbol at the cursor. The completions are presented in the editor's user interface. If computing full completion items is expensive, servers can additionally provide a handler for the completion item resolve request (\texttt{completionItem/resolve}). This request is sent when a completion item is selected in the user interface.

Usually, the completion is triggered by the user typing a character or pressing a keybinding in proximity to a character, such as \texttt{.}, \texttt{::}, or \texttt{->}.

In the figure \ref{fig:completion} we can see that the code completion is triggered by the user typing \texttt{to\_} and pressing \texttt{<C-n>} in the editor. Two float windows are shown with the completion items. The first one shows the options for the \texttt{to\_} function associated with the \texttt{\&str} type and the second one shows the documentation of the selected completion item.

\begin{figure}[h]
    \centering
    \fcolorbox{black}{white}{
        \includegraphics[width=0.9\linewidth]{imgs/background_completion.png}
    }
    \caption{Code completion in Neovim generated by the Rust Language Server.}
    \label{fig:completion}
\end{figure}

\subsection{Approaches to Source Code Analysis in Language Servers}\label{subsec:ApproachesToSourceCodeAnalysis}
Language servers handle source code analysis using various methods, influenced significantly by the complexity of the language. The choice of approach affects how servers process file indexes, manage changes, and respond to requests.

The Language Server Protocol (LSP) supports two methods for sending updates: diffs of atomic changes and complete transmission of changed files. The former requires incremental parsing and analysis, which are challenging to implement but enable much faster processing of files upon changes. Incremental parsing relies on an internal representation of the source code that allows efficient updates for small changes. This method necessitates providing the parser with the right context to correctly parse a changed fragment of code.

In practice, most language servers re-index the entire file when changes occur, discarding the previous internal state. This approach is more straightforward to implement as it poses fewer requirements for the architects of the language server, but it is significantly less performant. Unlike incremental processing, which updates only the affected portions of its internal structure, even minor changes such as adding or removing lines require reprocessing the entire file. This method may suffice for small languages and codebases but becomes a performance bottleneck with larger ones.

For code analysis, LSP implementers must choose between lazy and greedy approaches to processing files and answering requests. Greedy implementations resolve most available information during the file's initial indexing, enabling the server to answer requests using simple lookups. Conversely, lazy approaches resolve only minimal local information during indexing, invoking ad-hoc resolution for requests and possibly memoizing the results for future use. Lazy resolution is more common with incremental indexing, as it reduces the work associated with file changes, which is crucial for complex languages that would otherwise require a significant amount of redundant work.

\section{Language Workbenches}\label{sec:LanguageWorkbenches}

The term \textit{Language Workbench} was coined by Martin Fowler in 2005~\cite{Fowler05} to describe a set of tools that support the development of domain-specific languages (DSLs) in the context of \textit{language-oriented programming} paradigm~\cite{Ward94}.

A language workbench will typically include tools to support the definition, reuse and composition of domain-specific languages together with their integrated development environment.

Current language workbenches usually support:
\begin{itemize}
    \item Specification of the language concepts or metamodel
    \item Specification of the editing environments for the domain-specific language
    \item Specification of the execution semantics, e.g. through interpretation and code generation
\end{itemize}



Language workbenches have been developed for various technological spaces. Some of the most popular language workbenches are:
\begin{itemize}
    \item \textbf{JetBrains MPS}\footnote{\url{https://www.jetbrains.com/mps/}}: A powerful language workbench that allows the creation of domain-specific languages and the generation of code from them.
    \item \textbf{Xtext}\footnote{\url{https://www.eclipse.org/Xtext/}}: A framework for developing domain-specific languages and languages for code generation.
    \item \textbf{Spoofax}\footnote{\url{https://www.metaborg.org/en/latest/}}: A language workbench for developing textual domain-specific languages.
\end{itemize}

Instead, we discuss \texttt{Neverlang} (Sect.~\ref{subsec:neverlang}) in particular detail, since most of the research discussed in this dissertation will use \textsf{Neverlang} as a running example.

\subsection{Neverlang}\label{subsec:neverlang}

\begin{Listing}[t]
	% \begingroup
	% \catcode`\!=\active%
	% \def!#1!{\tikz[na]\coordinate(#1);\label{#1}}
	\setminted[neverlang]{escapeinside=@@}
	\showneverlang*{Backup.nl}\vskip -10pt%
	\caption{Syntax and semantics for the backup task.}\label{lst:backup}
	% \endgroup
	\newcommand{\nt}[1]{%
		\node[draw, fill=none, shape=circle, inner sep=0pt, minimum width=.375cm] (c\i) at (s\i) {};%
		\coordinate (d\i0p) at ($(d\i0)+(-1pt,2pt)$);% chktex 1
		\coordinate (d\i1p) at ($(d\i1)+(1pt,-3pt)$);% chktex 1
		\node[draw, thick, shape=rectangle, name=d\i, inner sep=1pt, fit=(d\i0p) (d\i1p)] {};% chktex 1 % chktex 36
	}
	\begin{tikzpicture}[overlay, thick, BloodRed]
		\coordinate (s0) at ($(s0)+(2pt,0pt)$) ;
		\foreach \i in {0, 1, 2} {%
			\nt{\i}
			\draw[-stealth, rounded corners=7pt] (c\i) -- (d\i);
		}
	\end{tikzpicture}
\end{Listing}

The \textit{Neverlang} \cite{Cazzola12c, Cazzola13e, Cazzola15c} framework promote the code reusability and the separation of concerns in the implementation of programming languages, based around the concept of \textit{language-feature}.
The basic development unit is the \textbf{module}, as shown in line 1 of Listing \ref{lst:backup}.
A module may contain a \textbf{reference syntax} and could have zero or multiple \textbf{role}s. A role, used to define the semantics, is unit of composition that defines actions that should be executed when some syntax is recognized, as defined by \textit{syntax-directed translation} \cite{Aho86}.
Syntax definitions are defined using \textit{Backusâ€“Naur form} (BNF) grammars, represented as sets of \textit{productions} and \textit{terminals}.
Syntax definitions and semantic \textbf{role}s are tied together using \textit{slice}s.
Listing \ref{lst:backup} shows a simple example of a Neverlang module implementing a backup task of the \texttt{LogLang} LPL. Reference syntax is defined in lines 2-6; the \textit{categories} (line 5) are used also to generate the syntax highlighting for the IDEs.
Semantic actions may be attached to a non-terminal using the production's name as a reference, or using the position of the non-terminal in the grammar, as shown in line 8, numbering start with 0 from the top left to the bottom right.
The two \textit{String} non-terminals on the right-hand side of the \textit{Backup} production are referenced using 1 and 2, respectively.
Different semantic actions may be attached to the same production thanks to the multiplicity of \textbf{role}s that can be defined for a module. Each \textbf{role} is a compilation phase that can be executed in a specific order, as shown in line 24.
In contrast, the \texttt{BackupSlice} (lines 14-18) reveals how the syntax and semantics are tied together; choosing the \texttt{concrete syntax} from the Backup module (line 15), and two \texttt{role}s from two different modules (lines 16-17).
Finally, the \texttt{language} can be created by composing multiple \textbf{slices} (line 20).
The composition in Neverlang is twofold: between modules and between slices. Thus, the grammars are merged in order to generate the complete language parser. On the other hand, the semantic actions are composed in a pipeline, and each \textbf{role} traverses the syntax tree in the order specified in the \textbf{roles} clause (line 24).



\section{Type Systems}\label{sec:TypeSystems}

\section{Software and Language Product Lines}\label{sec:SoftwareProductLines}
