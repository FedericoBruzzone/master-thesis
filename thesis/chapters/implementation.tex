\chapter{Implementation}\label{chap:Implementation}

All implementations in this chapter will be implemented in the \texttt{Java} programming language.

\section{The type system implementation}\label{sec:impl:TypeSystem}

In this section, we describe the implementation of the modular type system described in~\ref{sec:concept:TheTypeSystem} step by step.

\subsection{Type implementation: the basic building block}\label{sec:impl:Type}

\begin{Listing}[tb]
    \centering
    \showjava*[1\textwidth]{Type.java}
    \caption{The \texttt{Type} interface.}
    \label{lst:impl:Type}
\end{Listing}

The \texttt{Type} interface is the basic building block of the type system. As shown in Listing~\ref{lst:impl:Type}, the \texttt{Type} interface has four methods:
\begin{itemize}
    \item \texttt{String id()} that returns the unique identifier of the type.
    \item \texttt{boolean isAssignableFrom(Type other, Variance variance)} that returns \texttt{true} if the type is assignable from the \texttt{other} type with the given \texttt{variance}.
    \item \texttt{boolean matchSignature(Signature signature)} that returns \texttt{true} if the type matches the given \texttt{signature}.
    \item \texttt{Type bind(List<Type> neededTypes)} that returns the type bound to the given \texttt{neededTypes}.
\end{itemize}

The method \texttt{bind} could be used to bind a type to its generic parameters. For instance, the type \texttt{List<String>} is bound to the type \texttt{List<T>} with \texttt{neededTypes} being \texttt{String}. Another usage of the \texttt{bind} method is to bind a type function to its arguments. For instance, the type function \texttt{concat(T, U)} could be bound to the type function \texttt{concat(String, Integer)} with \texttt{neededTypes} being \texttt{String} and \texttt{Integer}.

Note that, the \texttt{Type} interface does not have a method to create a new type. This is because the type system is immutable. Once a type is created, it cannot be changed. This is to ensure that the type system is consistent and that the type system is thread-safe.

Additionally, the \texttt{Type} interface does not have a method to compare two types. This is because the type system is based on the \textbf{structural type system}~\cite{Cardelli88, Cook89}. Two types are equal if they have the same structure. For instance, the type \texttt{List<String>} is equal to the type \texttt{List<String>}. However, note that it is trivial pass to a \textbf{nominal type system}~\cite{Pierce02} by adding a method to compare two types based on their unique identifier.

\subsection{Scope implementation: the context of the type}\label{subsec:impl:Scope}

\begin{Listing}[tb]
    \centering
    \showjava*[1\textwidth]{Scope.java}
    \caption{The \texttt{Scope} interface.}
    \label{lst:impl:Scope}
\end{Listing}

The \texttt{Scope} interface is the context of the type. It is a generic interface that allows to the implementer to define the \textit{Java Type} of the identifier (\texttt{IDENTIFIER} in Line 1 of~\ref{lst:impl:Scope}).

As shown in Listing~\ref{lst:impl:Scope}, the \texttt{Scope} interface has seven main methods:

\begin{itemize}
    \item \texttt{TypingEnvironment<IDENTIFIER> getTypingEnvironment()} that returns the typing environment of the scope.
    \item \texttt{IDENTIFIER identifierFromToken(Token token)} that returns the identifier from the given \texttt{token}.
    \item \texttt{void setParent(Scope<IDENTIFIER> parent)} that sets the parent scope of the scope.
    \item \texttt{Optional<Scope<IDENTIFIER>> getParent()} that returns the parent scope of the scope.
    \item \texttt{void applyBinding(IDENTIFIER variable, SymbolTableEntry entry)} that applies the binding of the given \texttt{variable} to the given \texttt{symbol table entry}.
    \item \texttt{Stream<SymbolTableEntry> streamSymbolTableEntries()} that returns a stream of the symbol table entries of the scope.
    \item \texttt{InferenceResult inferFromSignature(Token token, Signature signature)} that infers the type of the given \texttt{token} from the given \texttt{signature}.
\end{itemize}

The \texttt{Scope} extends the \texttt{Type} interface~\ref{sec:impl:Type} to allow the scope to be used as a type. Reinforcing what was said in Section~\ref{subsec:concept:ScopeTheContextOfTheType}, we would like to keep the scope as generic as possible. This is to allow the scope to be used in different contexts. In addition, every scope has a typing environment that is a map of types (see Section~\ref{subsec:concept:TypingEnvironmentTheSymbolTable}). The \texttt{identifierFromToken} method is used to get the identifier from a token. The \texttt{setParent} method is used to set the parent scope of the scope. The \texttt{getParent} method is used to get the parent scope of the scope.
In order to apply the binding of a variable to a \texttt{SymbolTableEntry}~\ref{subsec:impl:SymbolTableEntry}, the scope has the \texttt{applyBinding} method. This method is used to bind a variable to a \texttt{SymbolTableEntry} in the scope. The \texttt{streamSymbolTableEntries} method is used to stream the symbol table entries of the scope. The \texttt{inferFromSignature} method is used to infer the type of a token from a signature.

\subsection{Signature implementation: the definition of a type}\label{subsec:impl:Signature}

\begin{Listing}[tb]
    \centering
    \showjava*[1\textwidth]{Signature.java}
    \caption{The \texttt{Signature} class.}
    \label{lst:impl:Signature}
\end{Listing}

The \texttt{Signature} class is the definition of a type. As shown in Listing~\ref{lst:impl:Signature}, the \texttt{Signature} class has one main method:
\begin{itemize}
    \item \texttt{SymbolTableEntry typeResolution(SymbolTableEntry entryType)} that returns the type resolution of the given \texttt{entryType}.
\end{itemize}

As mentioned in Section~\ref{subsec:concept:SignatureTheDefinitionOfTheType}, in order to perform \textit{type inference}, the \texttt{typeResolution} method can be used to do some operations on the type. For instance, the \texttt{typeResolution} method could be used to resolve the type of a variable. Another usage of the \texttt{typeResolution} method is to resolve the type of a function. For instance, immagine a varbiable that during the \textbf{parse} phase its type is marked as \textit{unknown}, because the type could be omitted. During the \textbf{resolve} phase, the type of the variable is resolved to a specific type.

\subsection{Symbol Table Entry Implementation: an entry in the Typing Environment}\label{subsec:impl:SymbolTableEntry}
\begin{Listing}[tb]
    \centering
    \showjava*[1\textwidth]{SymbolTableEntry.java}
    \caption{The \texttt{SymbolTableEntry} interface.}
    \label{lst:impl:SymbolTableEntry}
\end{Listing}

\texttt{SymbolTableEntry} is used to represent informations about symbols in the typing environment. As shown in Listing~\ref{subsec:impl:TypingEnvironment}, the \texttt{SymbolTableEntry} class has three main methods:

\begin{itemize}
    \item \texttt{EntryKind entryKind()} that returns the kind of the entry.
    \item \texttt{<T extends Type> T type()} that returns the type of the entry.
    \item \texttt{Location location()} that returns the location of the entry.
\end{itemize}

The \texttt{entryKind} method is used to get the kind of the entry, the in this case the kind of the entry is an \texttt{EntryKind} enum that can assume three different values: \texttt{DEFINE}, \texttt{USE}, and \texttt{IMPORT}. The \texttt{type} method is used to get the type of the entry, note that this method retrives the type as a generic type using \texttt{entryType} method that return an \texttt{EntryType}. An \texttt{EntryType} is a class that encapsulates the type of the entry and allow the retrival of the type from a \texttt{Token} during the \textbf{parse} phase.
The \texttt{location} method is used to get the location of the entry, the location is a class that encaps the information about the location of the entry in the source code.


\subsubsection{Entry Type Binder Implementation: an helper to perform type binding}\label{subsec:impl:EntryTypeBinder}

\begin{Listing}[tb]
    \centering
    \showjava*[1\textwidth]{EntryTypeBinder.java}
    \caption{The \texttt{EntryTypeBinder} interface.}
    \label{lst:impl:EntryTypeBinder}
\end{Listing}

The \texttt{EntryTypeBinder} class is an helper class that is used to perform type binding. As shown in Listing~\ref{lst:impl:EntryTypeBinder}, the \texttt{EntryTypeBinder} class has two main method:
\begin{itemize}
    \item \texttt{EntryTypeBinder bindEntry(SymbolTableEntry type)} that binds the given \texttt{type} to the entry.
    \item \texttt{boolean isBound()} that returns \texttt{true} if the entry is bound.
\end{itemize}

In our idea, a \texttt{SymbolTableEntry} should have a \texttt{SymbolTableEntry} inside it, that is used to check if the entry is bound or not. And the \texttt{bindEntry} method is used to bind the given \texttt{type} to the entry.

\subsection{Typing Environment implementation: the symbol table}\label{subsec:impl:TypingEnvironment}

\begin{Listing}[tb]
    \centering
    \showjava*[1\textwidth]{TypingEnvironment.java}
    \caption{The \texttt{TypingEnvironment} class.}
    \label{lst:impl:TypingEnvironment}
\end{Listing}

The \texttt{TypingEnvironment} class is the symbol table of the type system. As shown in Listing~\ref{lst:impl:TypingEnvironment}, the \texttt{TypingEnvironment} class has three main methods:

\begin{itemize}
    \item \texttt{TypingEnvironment<IDENTIFIER> bindTypeToIdentifier(IDENTIFIER variable, SymbolTableEntry anyType)} that binds the given \texttt{variable} to the given \texttt{anyType}.
    \item \texttt{Stream<SymbolTableEntry> getTypesBoundedWith(IDENTIFIER t)} that returns a stream of the types bounded with the given \texttt{t}.
    \item \texttt{void removeIf(Predicate<SymbolTableEntry> predicate)} that removes the entries that satisfy the given \texttt{predicate}.
\end{itemize}

The \texttt{TypingEnvironment} class contains a map (\texttt{HashMap<IDENTIFIER, EntryTypeBinder>}) from identifiers to \texttt{EntryTypeBinder}. One of the most important concepts is that the \texttt{EntryTypeBinder} can change, in fact in the constructor must be passed the class that extends \texttt{EntryTypeBinder} interface. This is to allow different kind of binding.
Hence, the first method \texttt{bindTypeToIdentifier} is used to bind the given \texttt{variable} to the given \texttt{SymbolTableEntry}. This method could fail if the \texttt{variable} is already bounded. The second method \texttt{getTypesBoundedWith} is used to get the types bounded with the given \texttt{t}. The third method \texttt{removeIf} is used to remove the entries that satisfy the given \texttt{predicate}.

